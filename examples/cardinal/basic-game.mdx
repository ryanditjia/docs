---
title: Basic Game Example
description: Learn World Engine v2 with a simple turn-based game example
---

# Basic Game Example

The Basic Game example demonstrates the core concepts of World Engine v2 through a simple
turn-based game. Players can create characters, attack each other, and regenerate health over
time.

## Overview

This example showcases:

- **Entity-Component-System (ECS)** architecture
- **Command processing** for player actions
- **System interactions** and game logic
- **Event emission** for client notifications
- **Inter-system communication** with system events

## Game Mechanics

### Core Gameplay

- **Player Creation**: Players can create characters with nicknames
- **Combat System**: Players can attack each other with damage
- **Health Regeneration**: Players automatically regenerate health
- **Death and Respawn**: Dead players create gravestones
- **Auto-spawn**: 10 default players are created on startup

### Game Flow

1. World starts with 10 default players
2. Players can create new characters
3. Players attack each other
4. Health regenerates over time
5. Dead players create gravestones in the graveyard

## Project Structure

```
basic/
├── main.go              # World setup and system registration
├── component/           # Game data components
│   ├── health.go        # Player health
│   ├── playertag.go     # Player identification
│   └── gravestone.go    # Graveyard markers
├── system/              # Game logic systems
│   ├── init_player_spawner.go   # Initial player creation
│   ├── player_spawner.go        # Player creation system
│   ├── player_attack.go         # Combat system
│   ├── regen.go                 # Health regeneration
│   ├── graveyard.go             # Gravestone creation
│   └── external.go              # Inter-shard communication
├── event/               # Game events
│   └── event.go         # Player events
├── system_event/        # Internal system events
│   └── system_event.go  # Cross-system communication
└── cmd/client/          # Test client
    └── main.go          # Command-line client
```

## Components

### PlayerTag Component

Identifies players in the game:

```go
type PlayerTag struct {
    Nickname string
}

func (PlayerTag) Name() string {
    return "PlayerTag"
}
```

### Health Component

Tracks player health:

```go
type Health struct {
    HP int
}

func (Health) Name() string {
    return "Health"
}
```

### Gravestone Component

Marks where players died:

```go
type Gravestone struct {
    Nickname string
}

func (Gravestone) Name() string {
    return "Gravestone"
}
```

## Systems

### Player Creation System

Handles `create-player` commands:

```go
type CreatePlayerCommand struct {
    cardinal.BaseCommand
    Nickname string `json:"nickname"`
}

func CreatePlayerSystem(state *CreatePlayerSystemState) error {
    for msg := range state.CreatePlayerCommands.Iter() {
        id, err := state.Players.Create(
            component.PlayerTag{Nickname: msg.Nickname},
            component.Health{HP: 100},
        )
        if err != nil {
            state.Logger().Error().Err(err).Msg("error creating entity")
            continue
        }

        state.NewPlayerEvents.Emit(event.NewPlayer{Nickname: msg.Nickname})
        state.Logger().Info().Uint32("entity", uint32(id)).
            Msgf("Created player %s", msg.Nickname)
    }
    return nil
}
```

### Combat System

Handles `attack-player` commands:

```go
type AttackPlayerCommand struct {
    cardinal.BaseCommand
    Target string
    Damage uint32
}

func AttackPlayerSystem(state *AttackPlayerSystemState) error {
    for msg := range state.AttackPlayerCommands.Iter() {
        for entity, player := range state.Players.Iter() {
            tag := player.Tag.Get()

            if msg.Target != tag.Nickname {
                continue
            }

            newHealth := player.Health.Get().HP - int(msg.Damage)
            if newHealth > 0 {
                player.Health.Set(component.Health{HP: newHealth})
                state.Logger().Info().
                    Msgf("Player %s received %d damage", msg.Target, msg.Damage)
            } else {
                entity.Destroy()
                state.PlayerDeathEvents.Emit(event.PlayerDeath{Nickname: tag.Nickname})
                state.PlayerDeathSystemEvents.Emit(
                    systemevent.PlayerDeath{Nickname: tag.Nickname})
                state.Logger().Info().Msgf("Player %s died", msg.Target)
            }
        }
    }
    return nil
}
```

### Health Regeneration System

Automatically regenerates player health:

```go
func RegenSystem(state *RegenSystemState) error {
    for entity, player := range state.Players.Iter() {
        health := player.Health.Get()
        if health.HP < 100 {
            newHealth := health.HP + 1
            player.Health.Set(component.Health{HP: newHealth})

            tag := player.Tag.Get()
            state.Logger().Info().Uint32("entity", uint32(entity.ID)).
                Msgf("Player %s regenerated health to %d", tag.Nickname, newHealth)
        }
    }
    return nil
}
```

### Graveyard System

Creates gravestones when players die:

```go
func GraveyardSystem(state *GraveyardSystemState) error {
    for event := range state.PlayerDeathSystemEvents.Iter() {
        _, _ = state.Graves.Create(component.Gravestone{Nickname: event.Nickname})
        state.Logger().Info().Msgf("Created grave stone for player %s", event.Nickname)
    }
    return nil
}
```

## Events

### Game Events

Events sent to clients:

```go
type PlayerDeath struct {
    cardinal.BaseEvent
    Nickname string
}

func (PlayerDeath) Name() string { return "player-death" }
func (PlayerDeath) Group() string { return "rampage" }

type NewPlayer struct {
    cardinal.BaseEvent
    Nickname string
}

func (NewPlayer) Name() string { return "new-player" }
```

### System Events

Internal events between systems:

```go
type PlayerDeath struct {
    Nickname string
}

func (PlayerDeath) Name() string { return "player-death" }
```

## World Setup

The main function sets up the world and registers systems:

```go
func main() {
    world := cardinal.NewWorld()

    // Initialize with default players
    cardinal.RegisterSystem(world, system.PlayerSpawnerSystem, cardinal.WithHook(cardinal.Init))

    // Register game systems
    cardinal.RegisterSystem(world, system.CreatePlayerSystem)
    cardinal.RegisterSystem(world, system.RegenSystem)
    cardinal.RegisterSystem(world, system.AttackPlayerSystem)
    cardinal.RegisterSystem(world, system.GraveyardSystem)
    cardinal.RegisterSystem(world, system.CallExternalSystem)

    world.StartGame()
}
```

## Running the Example

### Prerequisites

- Go 1.21 or later
- NATS server with JetStream enabled
- Docker (optional, for containerized deployment)

### Start the Game

```bash
cd pkg/cardinal/examples/basic
go run main.go
```

### Test with Client

The example includes a command-line client for testing:

```bash
# Create a new player
go run cmd/client/main.go create-player alice

# Attack another player
go run cmd/client/main.go attack-player alice 25

# Query game state
go run cmd/client/main.go query '{"find":["PlayerTag","Health"],"match":"exact"}'

# Listen for events
go run cmd/client/main.go listen player-death
```

## Key Learning Points

### ECS Architecture

- **Components** store data only (PlayerTag, Health)
- **Systems** contain all game logic
- **Entities** are combinations of components

### Command Processing

- Commands are processed in batches during game ticks
- Systems receive commands through `WithCommand` fields
- Commands are automatically registered when systems use them

### Event System

- **Game Events** notify external clients
- **System Events** enable cross-system communication
- Events are emitted during system execution

### System Hooks

- **Init**: Runs once during world initialization
- **Update**: Main game logic phase (default)
- Systems run in deterministic order

### Query System

- Systems use typed queries for efficient entity iteration
- Queries automatically match entities with required components
- Support for exact matches and filtering

## Next Steps

Explore more advanced examples:

- [Demo Game Example](/examples/cardinal/demo-game) - Real-time multiplayer
- [Chat System Example](/examples/cardinal/chat-system) - Social features
- [Client Integration Examples](/examples/client/unity-integration) - Game engine integration

Learn more about the concepts:

- [ECS Architecture](/architecture/ecs)
- [Command System](/cardinal/build/command/overview)
- [Event System](/cardinal/build/events/overview)
- [System Development](/cardinal/build/system)
