---
title: Events Overview
description: Understanding events in World Engine v2 - reactive game state notifications
---

# Events Overview

Events in World Engine v2 provide a way for your game to communicate state changes and
important occurrences to clients in real-time. Events are emitted by systems during game
execution and can be subscribed to by clients for reactive gameplay experiences.

## What are Events?

Events in World Engine v2 are:

- **Notifications**: Messages about what happened in the game
- **Reactive**: Allow clients to respond to game state changes
- **Real-Time**: Published immediately after game tick processing
- **Typed**: Strongly typed for safety and clarity

## Event Types

### Game Events

Events that are published to external clients:

- **Player Actions**: Movement, combat, item usage
- **World Changes**: Environmental updates, state changes
- **Social Events**: Chat messages, player interactions

### System Events

Internal events for communication between systems:

- **Cross-System**: Share data between different systems
- **Lifecycle**: Entity creation/destruction notifications
- **Triggers**: Activate secondary game logic

## Basic Event Structure

All events must embed `cardinal.BaseEvent`:

```go
type PlayerDeathEvent struct {
    cardinal.BaseEvent
    PlayerID   string    `json:"player_id"`
    Killer     string    `json:"killer,omitempty"`
    Location   Position  `json:"location"`
    Timestamp  time.Time `json:"timestamp"`
}

func (PlayerDeathEvent) Name() string {
    return "player-death"
}

func (PlayerDeathEvent) Group() string {
    return "combat"
}
```

## Event Registration and Emission

### System Event Emission

Systems emit events during their execution:

```go
type CombatSystemState struct {
    cardinal.BaseSystemState
    AttackCommands   cardinal.WithCommand[AttackCommand]
    PlayerDeathEvent cardinal.WithEvent[PlayerDeathEvent]
    Players          PlayerSearch
}

func CombatSystem(state *CombatSystemState) error {
    for cmd := range state.AttackCommands.Iter() {
        // Process attack logic...

        if playerHealth <= 0 {
            // Emit event when player dies
            state.PlayerDeathEvent.Emit(PlayerDeathEvent{
                PlayerID:  cmd.Target,
                Killer:    cmd.Attacker,
                Location:  playerPosition,
                Timestamp: time.Now(),
            })
        }
    }
    return nil
}
```

### Event Publishing

Events are automatically published after all systems complete:

- **Batched**: All events from a tick are published together
- **Ordered**: Events maintain the order they were emitted
- **Filtered**: Clients receive only relevant events

## System Events (Internal)

For communication between systems within Cardinal:

```go
type PlayerDeathSystemEvent struct {
    PlayerID string
    Location Position
}

func (PlayerDeathSystemEvent) Name() string {
    return "player-death-internal"
}

// Emitting system
type CombatSystemState struct {
    cardinal.BaseSystemState
    PlayerDeathSystemEvents cardinal.WithSystemEventEmitter[PlayerDeathSystemEvent]
}

func CombatSystem(state *CombatSystemState) error {
    // When player dies, emit system event
    state.PlayerDeathSystemEvents.Emit(PlayerDeathSystemEvent{
        PlayerID: deadPlayerID,
        Location: deathLocation,
    })
    return nil
}

// Receiving system
type GraveyardSystemState struct {
    cardinal.BaseSystemState
    PlayerDeathEvents cardinal.WithSystemEventReceiver[PlayerDeathSystemEvent]
    Graves           GraveSearch
}

func GraveyardSystem(state *GraveyardSystemState) error {
    for event := range state.PlayerDeathEvents.Iter() {
        // Create gravestone where player died
        state.Graves.Create(Gravestone{
            PlayerID: event.PlayerID,
            Location: event.Location,
        })
    }
    return nil
}
```

## Client Event Subscription

### JavaScript SDK

Use the JavaScript SDK to subscribe to events:

```javascript
import { createSDK } from '@argus-labs/world-engine-sdk'

const sdk = createSDK({
  baseUrl: 'http://localhost:4040',
})

// Subscribe to specific events
sdk.subscribeEvents(['player-death', 'player-spawn'], (event) => {
  console.log('Game event:', event)
  handleGameEvent(event)
})

// Subscribe to event groups
sdk.subscribeEventGroups(['combat', 'social'], (event) => {
  console.log('Group event:', event)
  handleGroupEvent(event)
})
```

### Event Filtering

Subscribe to specific event types or groups:

```javascript
// Subscribe to combat events only
sdk.subscribeEventGroups(['combat'], (event) => {
  handleCombatEvent(event)
})

// Subscribe to multiple specific event types
sdk.subscribeEvents(['player-death', 'player-spawn'], (event) => {
  handlePlayerLifecycleEvent(event)
})
```

## Event Groups

Organize events into logical groups for easier management:

```go
type ChatEvent struct {
    cardinal.BaseEvent
    PlayerID string `json:"player_id"`
    Message  string `json:"message"`
}

func (ChatEvent) Name() string { return "chat-message" }
func (ChatEvent) Group() string { return "social" }

type TradeEvent struct {
    cardinal.BaseEvent
    Buyer  string `json:"buyer"`
    Seller string `json:"seller"`
    Item   string `json:"item"`
    Price  int    `json:"price"`
}

func (TradeEvent) Name() string { return "trade-completed" }
func (TradeEvent) Group() string { return "economy" }
```

## Best Practices

### Event Design

- **Clear Names**: Use descriptive event names
- **Consistent Groups**: Organize events logically
- **Minimal Data**: Include only necessary information
- **Immutable**: Events should not change after emission

### Performance

- **Efficient Emission**: Don't emit events in tight loops
- **Batch Events**: Group related events when possible
- **Filter Early**: Use specific subscriptions to reduce bandwidth
- **Async Processing**: Handle events asynchronously in clients

### Error Handling

- **Graceful Failures**: Handle event processing errors
- **Retry Logic**: Implement retry for critical events
- **Dead Letter**: Log failed event processing
- **Circuit Breaker**: Prevent cascading failures

## Examples

### Player Combat Events

```go
type PlayerAttackEvent struct {
    cardinal.BaseEvent
    Attacker string   `json:"attacker"`
    Target   string   `json:"target"`
    Damage   int      `json:"damage"`
    Weapon   string   `json:"weapon"`
    Critical bool     `json:"critical"`
}

func (PlayerAttackEvent) Name() string { return "player-attack" }
func (PlayerAttackEvent) Group() string { return "combat" }

type PlayerDeathEvent struct {
    cardinal.BaseEvent
    PlayerID  string   `json:"player_id"`
    Killer    string   `json:"killer,omitempty"`
    Location  Position `json:"location"`
    DropItems []string `json:"drop_items"`
}

func (PlayerDeathEvent) Name() string { return "player-death" }
func (PlayerDeathEvent) Group() string { return "combat" }
```

### World Events

```go
type WorldWeatherEvent struct {
    cardinal.BaseEvent
    Weather   string    `json:"weather"`
    Intensity float64   `json:"intensity"`
    Duration  time.Duration `json:"duration"`
    Region    string    `json:"region"`
}

func (WorldWeatherEvent) Name() string { return "weather-change" }
func (WorldWeatherEvent) Group() string { return "world" }
```

## Testing Events

### Unit Testing

Test event emission in your systems:

```go
func TestCombatSystem_EmitsPlayerDeathEvent(t *testing.T) {
    // Set up test world with combat system
    world := cardinal.NewTestWorld(t)
    cardinal.RegisterSystems[CombatSystemState](world, CombatSystem)
    cardinal.RegisterEvents[PlayerDeathEvent](world)

    // Create entities and run system
    playerID := world.Create(PlayerTag{}, Health{HP: 1})

    // Process attack that should kill player
    world.SendCommand(AttackCommand{
        Target: playerID,
        Damage: 10,
    })

    world.Tick()

    // Verify event was emitted
    events := world.GetEmittedEvents()
    assert.Len(t, events, 1)
    assert.Equal(t, "player-death", events[0].Name())
}
```

### Integration Testing

Test end-to-end event flow:

```javascript
// Client-side integration test
test('receives player death events', async () => {
  const events = []

  sdk.subscribeEvents(['player-death'], (event) => {
    events.push(event)
  })

  // Trigger player death in game
  await sdk.command('attack-player', {
    target: 'test-player',
    damage: 999,
  })

  // Wait for event
  await waitFor(() => {
    expect(events).toHaveLength(1)
    expect(events[0].type).toBe('player-death')
  })
})
```

## Next Steps

- [Event Groups Reference](/cardinal/build/events/event-groups)
- [System Events Deep Dive](/cardinal/build/events/system-events)
- [Client Event Handling](/javascript/guides/subscribe-events)
- [Performance Optimization](/cardinal/advanced/performance)
