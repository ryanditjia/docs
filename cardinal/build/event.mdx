---
title: Event
description: Understanding events in World Engine v2 - reactive game state notifications
---

Events in World Engine v2 provide a way for your game to communicate state changes and
important occurrences to clients in real-time. Events are emitted by systems during game
execution and can be subscribed to by clients for reactive gameplay experiences.

## What are Events?

Events in World Engine v2 are:

- **Notifications**: Messages about what happened in the game
- **Reactive**: Allow clients to respond to game state changes
- **Real-Time**: Published immediately after game tick processing
- **Typed**: Strongly typed for safety and clarity

## Event Types

### Game Events

Events that are published to external clients:

- **Player Actions**: Movement, combat, item usage
- **World Changes**: Environmental updates, state changes
- **Social Events**: Chat messages, player interactions

### System Events

Internal events for communication between systems:

- **Cross-System**: Share data between different systems
- **Lifecycle**: Entity creation/destruction notifications
- **Triggers**: Activate secondary game logic

## Basic Event Structure

All events must embed `cardinal.BaseEvent`:

```go
type PlayerDeathEvent struct {
    cardinal.BaseEvent
    PlayerID   string    `json:"player_id"`
    Killer     string    `json:"killer,omitempty"`
    Location   Position  `json:"location"`
    Timestamp  time.Time `json:"timestamp"`
}

func (PlayerDeathEvent) Name() string {
    return "player-death"
}

func (PlayerDeathEvent) Group() string {
    return "combat"
}
```

## Event Registration and Emission

### System Event Emission

Systems emit events during their execution:

```go
type CombatSystemState struct {
    cardinal.BaseSystemState
    AttackCommands   cardinal.WithCommand[AttackCommand]
    PlayerDeathEvent cardinal.WithEvent[PlayerDeathEvent]
    Players          PlayerSearch
}

func CombatSystem(state *CombatSystemState) error {
    for cmd := range state.AttackCommands.Iter() {
        // Process attack logic...

        if playerHealth <= 0 {
            // Emit event when player dies
            state.PlayerDeathEvent.Emit(PlayerDeathEvent{
                PlayerID:  cmd.Target,
                Killer:    cmd.Attacker,
                Location:  playerPosition,
                Timestamp: time.Now(),
            })
        }
    }
    return nil
}
```

### Event Publishing

Events are automatically published after all systems complete:

- **Batched**: All events from a tick are published together
- **Ordered**: Events maintain the order they were emitted
- **Filtered**: Clients receive only relevant events

## System Events (Internal)

For communication between systems within Cardinal:

```go
type PlayerDeathSystemEvent struct {
    PlayerID string
    Location Position
}

func (PlayerDeathSystemEvent) Name() string {
    return "player-death-internal"
}

// Emitting system
type CombatSystemState struct {
    cardinal.BaseSystemState
    PlayerDeathSystemEvents cardinal.WithSystemEventEmitter[PlayerDeathSystemEvent]
}

func CombatSystem(state *CombatSystemState) error {
    // When player dies, emit system event
    state.PlayerDeathSystemEvents.Emit(PlayerDeathSystemEvent{
        PlayerID: deadPlayerID,
        Location: deathLocation,
    })
    return nil
}

// Receiving system
type GraveyardSystemState struct {
    cardinal.BaseSystemState
    PlayerDeathEvents cardinal.WithSystemEventReceiver[PlayerDeathSystemEvent]
    Graves           GraveSearch
}

func GraveyardSystem(state *GraveyardSystemState) error {
    for event := range state.PlayerDeathEvents.Iter() {
        // Create gravestone where player died
        state.Graves.Create(Gravestone{
            PlayerID: event.PlayerID,
            Location: event.Location,
        })
    }
    return nil
}
```
