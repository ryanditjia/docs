---
title: Command
description: Understanding commands in World Engine v2 - how players interact with your game
---

Commands are the primary way players interact with your game world. They represent actions that players
want to perform, such as moving, attacking, or chatting. Commands modify game state and are processed
deterministically during each game tick.

## What are Commands?

Commands in World Engine v2 are:

- **Actions**: Player intentions to modify game state
- **Validated**: Checked for authenticity and structure
- **Queued**: Processed in batches during game ticks
- **Deterministic**: Same command always produces same result

## Command Lifecycle

1. **Creation**: Client creates and signs command
2. **Transmission**: Command sent to Cardinal via API
3. **Validation**: Signature and structure verified
4. **Queuing**: Command queued for next tick
5. **Processing**: System handles command during tick
6. **Events**: Systems emit events based on results

## Basic Command Structure

All commands must embed `cardinal.BaseCommand`:

```go
type CreatePlayerCommand struct {
    cardinal.BaseCommand
    Nickname string `json:"nickname"`
}

func (CreatePlayerCommand) Name() string {
    return "create-player"
}
```

## Command Registration

Commands are automatically registered when systems use them:

```go
type CreatePlayerSystemState struct {
    cardinal.BaseSystemState
    CreatePlayerCommands cardinal.WithCommand[CreatePlayerCommand]
    // ... other fields
}

func CreatePlayerSystem(state *CreatePlayerSystemState) error {
    for command := range state.CreatePlayerCommands.Iter() {
        // Process the command
        processCreatePlayer(command)
    }
    return nil
}
```

## Command Processing

### Batch Processing

Commands are processed in batches during each tick:

- All commands for a tick are collected first
- Systems process commands in deterministic order
- Results are consistent across all game instances

### System Integration

Systems receive commands through the `WithCommand` field:

```go
type PlayerSystemState struct {
    cardinal.BaseSystemState
    MoveCommands   cardinal.WithCommand[MoveCommand]
    AttackCommands cardinal.WithCommand[AttackCommand]
    Players        PlayerSearch
}

func PlayerSystem(state *PlayerSystemState) error {
    // Process movement commands
    for cmd := range state.MoveCommands.Iter() {
        handleMove(cmd, state.Players)
    }

    // Process attack commands
    for cmd := range state.AttackCommands.Iter() {
        handleAttack(cmd, state.Players)
    }

    return nil
}
```

## Command Validation

### Automatic Validation

World Engine automatically validates:

- **Structure**: Command matches expected schema
- **Signature**: Command is properly signed (if enabled)
- **Authentication**: Player has permission to execute

## Error Handling

### Graceful Error Handling

Systems should handle errors without crashing:

```go
func CreatePlayerSystem(state *CreatePlayerSystemState) error {
    for cmd := range state.CreatePlayerCommands.Iter() {
        if err := validateNickname(cmd.Nickname); err != nil {
            state.Logger().Error().Err(err).Msg("invalid nickname")
            continue // Skip this command, don't crash
        }

        // Process valid command
        createPlayer(cmd, state)
    }
    return nil
}
```

### Error Feedback

While commands don't return responses directly, you can:

- Emit error events for clients to handle
- Log errors for debugging
- Update game state to reflect failures
